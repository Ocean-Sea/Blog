
# 附则

## 用户空间和内核空间

- 现在操作系统都采用虚拟寻址，处理器先产生一个虚拟地址，通过虚拟地址翻译成物理地址（内存地址）， 在通过线程总数传递，最后处理器拿到某个物理地址返回字节。

- 对 32 位操作系统而言，他的寻址空间（虚拟存储空间）位 4G(2的32次方)，操作系统核心是内核， 独立于普通的应用程序。可以访问受保护的内存空间， 也有访问底层硬件设备的所有权限，为了保证用户程序不能操作内核，操作系统将虚拟空间分为两部分，一部分为内核空间，一分为用户空间。

- 针对`Linux`操作系统而言，将最高的`1G`字节（从虚拟机地址`0xC0000000`到`0xFFFFFFFF`），供内核使用，成为内核空间。而将低的`3G`字节（从虚拟地址`0x00000000`到`0xBFFFFFFF`）共各个进程使用，成为用户空间。

- 地址空间就是一个非负整数地址的集合， 如`{1,2,3...}`。

## 进程上下文切换（进程切换）

- 为了控制进程的执行，内核必须有能力挂起正在`CPU`上的运行的进程。并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。

- 从一个进程的运行转到另一个进程上运行，这个进程中经过下面这些变化：
  - 1. 保存当前进程`A`的上下文，上下文就是内核再次唤醒当前进程时所需要的状态，由一些对象的值的组成

  - 2. 恢复成进程`B`的上下文。


## 进程阻塞

- 正在执行的进程， 由于期待的某些事件未发生，将自己的运行状态变为成阻塞状态。

- 进程的阻塞是进程自身的一种主动行为，为因为只有处于运行态的进程（获取`CPU`）,才能将其转为阻塞状态，当进程进入阻塞状态， 是不占用`CPU`资源。

## 文件描述符
- 内核（kernel）利用文件描述符（file descriptor）来访问文件。

- 文件描述符是一种一个用于表达指向文件的引用的抽象化概念。

- 当程序打开一个现有文件或者创建一个新文件时， 内核向进程返回一个文件描述符。

## IO模式

- 对于一个`IO访问`以（`read`举例），数据会先被拷贝到操作系统的内核缓冲区，然后才会从操作系统内核的缓冲区拷贝到应用程序的缓冲区，最后交给进程。所以说，当一个`read`操作系统发生时，它会经历两个阶段：

-  等待数据准备。

- 将数据从内核拷贝到进程中。

## 分类

- 同步阻塞`IO`。

- 同步非阻塞`IO`。

- 异步阻塞`IO`(`IO`多路复用)。

- 异步非阻塞`IO`。

## 事件模型

- 目前支持`IO`多路复用的系统调用有`select`、`poll`、`epoll`。

- `IO`多路复用就是通过一种机制， 一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

- 但`select`、`poll`、`epoll`本质上都是同步`IO`,因为他们都需要在读写事件就绪后自己负责进行读写，也就是读写过程是阻塞的。


|  事件模型   | 描述  |
|  ----      | ----  |
| select | 单个进程能打开的最大连接数为`1024`, 因为需要对多有的文件描述符进行线性遍历，所以文件描述符太多会导致性能下降。|
| poll   | 和select基本一样，因为用链表存储文件描述符，没有最大的连接数限制。 |
| epoll  | `epoll`是在每个文件描述符上设置`callback`来实现，`FD`就绪后才会调用`callback`,活跃`socket`少的话性能高， `socket`活跃多的话性能低。